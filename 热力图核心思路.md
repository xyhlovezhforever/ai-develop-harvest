# 热力图绘制核心思路

## 目录
1. [总体架构](#总体架构)
2. [数据结构](#数据结构)
3. [关键模块](#关键模块)
4. [绘制流程](#绘制流程)
5. [坐标系统](#坐标系统)
6. [颜色方案](#颜色方案)
7. [特殊处理](#特殊处理)

---

## 总体架构

```
用户交互（选择机房、高度、类型）
    ↓
handlePredict() - API 请求
    ↓
数据处理和验证
    ↓
updateChart() - 热力图更新
    ↓
ECharts 图表渲染 + Graphic 绘制矩形
```

### 核心流程

1. **初始化** - 页面加载时调用 `initChart()` 初始化 ECharts 实例
2. **数据获取** - 用户选择机房、高度或类型时调用 `handlePredict()` 获取热力图数据
3. **数据处理** - 对 API 返回的数据进行清洗、插值、温度范围计算
4. **图表更新** - 调用 `updateChart()` 使用 ECharts 的 `setOption()` 更新热力图
5. **矩形绘制** - 在 `nextTick` 中使用 ECharts `graphic` 绘制 10 个通道矩形框

---

## 数据结构

### 1. 矩形通道位置数据

```javascript
let rectPositions = {
  one: {
    positions: [
      [8, 24],      // 左上角 [x, y]
      [25, 24],     // 右上角
      [8, 65],      // 左下角
      [25, 65]      // 右下角
    ],
    name: '1号通道',
  },
  // ... 二到十号通道
}
```

**坐标系统**：物理坐标（0-135 范围）
- X 轴：0-135（宽度）
- Y 轴：0-135（高度）
- 这些坐标**独立于热力图数据的维度**，表示真实物理空间位置

### 2. 热力图数据结构

```javascript
// API 返回的原始数据
heatmapData: number[][] // 二维数组，例如 144×138 的矩阵

// 经过处理后的数据格式
[
  [x, y, value],  // x: 列索引，y: 行索引，value: 温度值
  [x, y, value],
  // ...
]
```

### 3. 显示类型

```javascript
displayType.value: 0 | 1
// 0 = 温度场 (℃)
// 1 = 速度场 (m/s)
```

---

## 关键模块

### 1. 数据插值模块 - `interpolateData()`

**目的**：使用高斯插值平滑原始数据，提高热力图的视觉效果

**过程**：
```
原始数据 (小尺寸, 如 50×50)
    ↓
高斯核平滑
    ↓
目标尺寸数据 (大尺寸, 如 144×138)
```

**关键参数**：
- `interpolationScale`: 插值倍数（1x, 2x, 3x）
- 根据数据大小自动选择：
  - 数据 > 20000 个点 → 不插值（1x）
  - 数据 > 10000 个点 → 2x 插值
  - 数据 ≤ 10000 个点 → 3x 插值

### 2. 温度范围计算模块

**目的**：动态计算热力图的温度范围，确保颜色分布合理

**算法**：

```javascript
// 1. 收集所有有效温度值
validTemps = [...]

// 2. 排序并计算百分位数（过滤异常值）
p2Index = Math.floor(validTemps.length * 0.02)
p98Index = Math.floor(validTemps.length * 0.98)

// 3. 特殊处理：全0数据
if (rawMinTemp === 0 && rawMaxTemp === 0) {
  minTemp = 0
  maxTemp = 1  // 确保显示为蓝色（最低值）
}

// 4. 正常数据：确保最小范围（避免范围为0）
const minRange = 2  // 最小 2℃ 的跨度
if (tempRange < minRange) {
  // 扩展范围使其满足最小跨度
}

// 5. 扩展范围（前后各扩展 5%）
minTemp = Math.floor((minTemp - padding) * 10) / 10
maxTemp = Math.ceil((maxTemp + padding) * 10) / 10
```

### 3. 坐标转换模块

**功能**：将物理坐标转换为热力图的格点坐标，再转换为像素坐标

```javascript
// 物理坐标（0-135）→ 格点坐标（0到cols-1/rows-1）
const topLeftGrid = [
  (topLeftPhys[0] / 135) * (cols - 1),
  (topLeftPhys[1] / 135) * (rows - 1)
]

// 格点坐标 → 像素坐标（屏幕像素）
const pixelTopLeft = chartInstance.convertToPixel(
  { gridIndex: 0 }, 
  topLeftGrid
)
```

**三层坐标系统**：
1. **物理坐标** - 真实空间位置 (0-135)
2. **格点坐标** - 热力图数据矩阵索引 (0-cols, 0-rows)
3. **像素坐标** - 屏幕渲染坐标 (screen x, y)

---

## 绘制流程

### 1. 初始化流程 (`initChart`)

```javascript
initChart() {
  1. 创建 ECharts 实例
  2. 注册鼠标事件监听器
  3. 调用 updateChart() 显示初始数据
}
```

### 2. 预测流程 (`handlePredict`)

```javascript
handlePredict() {
  1. 标记正在预测
  2. 调用 API: getAirflowOrganizationProxyModel({
       room_key: selectedRoom.value,
       plane_value: selectedHeight.value,
       type: displayType.value  // 0=温度, 1=速度
     })
  
  3. 特殊处理 5 楼：
     - 如果是 5 楼且请求失败 → 显示全 0 热力图
     - 如果是其他楼层失败 → 显示错误信息
  
  4. 处理返回数据：
     if (res.success && res.obj) {
       提取 heatmapData 和 rectPositionsData
       if (is5thFloor && no_data) {
         生成全 0 热力图
       }
       updateChart(heatmapData, rectPositionsData)
     }
}
```

### 3. 图表更新流程 (`updateChart`)

```javascript
updateChart(apiData) {
  1. 数据缓存
     - 保存 API 返回的数据用于窗口改变时重新渲染
  
  2. 数据插值
     - 根据数据大小选择插值倍数
     - 调用 interpolateData() 平滑处理
  
  3. 温度范围计算
     - 动态计算 minTemp 和 maxTemp
     - 处理全 0 数据的特殊情况
  
  4. 数据转换
     - 将二维数组转换为 ECharts 热力图格式
     - 格式: [[x, y, value], [x, y, value], ...]
  
  5. 构建 ECharts 配置对象
     - xAxis/yAxis 配置（Category 类型）
     - series 配置（Heatmap 类型）
     - visualMap 配置（颜色标尺）
  
  6. 更新图表
     chartInstance.setOption(option, {
       notMerge: true,
       lazyUpdate: false,
       silent: true
     })
  
  7. 绘制矩形框和文字（在 nextTick 中）
     - 使用 graphic 绘制 10 个通道矩形
     - 每个矩形包括：
       * 矩形边框（暗色）
       * 竖排文字标签（根据背景自适应颜色）
}
```

---

## 坐标系统

### 坐标系三层结构

#### 层级 1：物理坐标系
```
(0, 0) ─────→ X 轴 (0-135)
  │
  │
  ↓
Y 轴 (0-135)

用途：定义 10 个通道的真实位置
独立性：不受热力图数据维度影响
```

#### 层级 2：热力图格点坐标系
```
原始数据可能是 50×50 或 100×100
经过插值后统一为 144×138

(0, 0) ──────→ X 轴 (0-137)
  │
  │
  ↓
Y 轴 (0-143)

用途：ECharts 热力图的数据坐标
计算方式：
gridX = (physicalX / 135) * (cols - 1)
gridY = (physicalY / 135) * (rows - 1)
```

#### 层级 3：像素坐标系
```
屏幕左上角 (0, 0) ────→ X 轴 (屏幕宽度)
           │
           │
           ↓
        Y 轴 (屏幕高度)

用途：Graphic 绘制矩形和文字
获取方式：chartInstance.convertToPixel({ gridIndex: 0 }, gridCoord)
```

### 坐标转换过程

```
物理坐标 [8, 24]
    ↓
    × (cols-1)/135, × (rows-1)/135
    ↓
格点坐标 [x_grid, y_grid]
    ↓
    convertToPixel()
    ↓
像素坐标 [x_px, y_px]
    ↓
Graphic 绘制矩形
```

---

## 颜色方案

### 1. 温度场颜色方案

**颜色梯度**：蓝 → 青 → 绿 → 黄 → 橙 → 红

```
#0a1e5c (深蓝)    →  低温
#4fddff (浅青)    →  中低温
#70ff8c (浅绿)    →  中温
#fff024 (黄)      →  中高温
#ff6400 (橙)      →  高温
#c80000 (深红)    →  超高温
```

**应用**：
- `visualMap.inRange.color = temperatureColors` (displayType === 0)
- 64 个颜色值均匀分布在温度范围内
- 精度设置为 1 位小数

### 2. 速度场颜色方案

**颜色梯度**：深蓝 → 蓝 → 浅蓝 → 白 → 浅红 → 红 → 深红

```
#00008B (深蓝)    →  低速
#0055FF (蓝)      →  低中速
#00FFFF (浅蓝)    →  中低速
#FFFFFF (白)      →  中速
#FF5F5F (浅红)    →  中高速
#FF0000 (红)      →  高速
#610000 (深红)    →  超高速
```

**应用**：
- `visualMap.inRange.color = velocityColors` (displayType === 1)
- 64 个颜色值均匀分布在速度范围内
- 精度设置为 1 位小数，单位 m/s

### 3. 特殊情况：全 0 数据

```javascript
if (rawMinTemp === 0 && rawMaxTemp === 0) {
  minTemp = 0
  maxTemp = 1
  // 所有值 0 都会映射到颜色数组的最低端 → 深蓝色
}
```

---

## 特殊处理

### 1. 5 楼机房特殊处理

**场景**：5 楼机房没有实际数据（还没有安装机器）

**处理方案**：

```javascript
if (selectedRoom.value && selectedRoom.value.includes('5')) {
  // 1. API 请求成功但返回空数据
  if (res.success && res.obj && heatmapData.length === 0) {
    heatmapData = 全 0 数据
  }
  
  // 2. API 请求失败（无效的机房编号）
  else if (res && !res.success) {
    heatmapData = 全 0 数据
    不显示错误信息
  }
  
  // 3. API 请求异常
  catch (error) {
    heatmapData = 全 0 数据
    不显示错误信息
  }
}
```

### 2. 文字颜色自适应

**问题**：深蓝色背景下暗色文字看不清

**解决方案**：

```javascript
const isAllZeroData = rawMinTemp === 0 && rawMaxTemp === 0
const textColor = isAllZeroData ? '#ffffff' : '#1a1a1a'

// 全 0 数据 → 白色文字（在深蓝色背景上清晰）
// 其他数据 → 暗色文字（在彩色背景上清晰）
```

### 3. 响应式设计

**字体大小配置**：

```javascript
const chartFontSizes = {
  mobile: {
    axisLabel: 7,           // 移动端坐标轴标签
    visualMapText: 8,       // 移动端色彩标尺文字
    visualMapBorderWidth: 1,
  },
  desktop: {
    axisLabel: 14,          // PC 端坐标轴标签
    visualMapText: 16,      // PC 端色彩标尺文字
    visualMapBorderWidth: 2,
  },
}

// 使用场景
fontSize: isMobile ? chartFontSizes.mobile.axisLabel 
                   : chartFontSizes.desktop.axisLabel
```

### 4. 矩形框线绘制

**矩形特性**：

```javascript
// 1. 坐标转换
物理坐标 (0-135) → 格点坐标 → 像素坐标

// 2. 矩形框
- 颜色：暗色 (#1a1a1a)
- 宽度：2px
- 填充：透明（不遮挡热力图）

// 3. 文字标签
- 方式：竖排显示（每个字符一行）
- 字体：粗体，大小自适应
- 颜色：根据背景自动调整
- 位置：矩形中心

// 4. Z-index 分层
- 矩形框：z: 100
- 文字：z: 101
```

### 5. 窗口大小变化处理

**防抖机制**：

```javascript
let resizeTimer: number | null = null
const handleResize = () => {
  if (resizeTimer) clearTimeout(resizeTimer)
  
  resizeTimer = window.setTimeout(() => {
    chartInstance.resize()  // 调整图表大小
    updateChart()           // 重新渲染（使用缓存数据）
  }, 150)  // 150ms 防抖延迟
}

// 监听窗口变化
window.addEventListener('resize', handleResize)
```

---

## 关键计算

### 1. 正方形容器计算

```javascript
// 保证热力图显示为正方形

const containerWidth = chartRef.value.clientWidth
const containerHeight = chartRef.value.clientHeight

const leftSpace = 50          // 左边坐标轴
const rightSpace = 100        // 右边图例
const topSpace = 20           // 顶部
const bottomSpace = 70        // 底部坐标轴

const availableWidth = containerWidth - leftSpace - rightSpace
const availableHeight = containerHeight - topSpace - bottomSpace

// 取较小值作为正方形边长，尽可能大
const squareSize = Math.min(availableWidth, availableHeight)

// 居中位置
const centerLeft = leftSpace + (availableWidth - squareSize) / 2
const centerTop = topSpace + (availableHeight - squareSize) / 2
```

### 2. 字体大小计算

```javascript
// 矩形框内的文字大小

// 基于矩形宽度自适应
const rackWidth = Math.abs(topRight[0] - topLeft[0])  // 格点坐标
const fontSize = Math.max(12, Math.floor(width * 0.15))  // width 是像素宽度

// 竖排文字的行间距
const unifiedLineHeight = unifiedFontSize + 2

// 竖排文字的起始 Y 坐标（居中）
const startY = centerY - (channelText.length - 1) * fontSize / 2
```

### 3. 标尺文字格式

```javascript
// 根据显示类型格式化标尺文字

if (displayType.value === 0) {
  // 温度场
  return `${value.toFixed(0)}℃`
} else {
  // 速度场
  return `${value.toFixed(1)}m/s`
}
```

---

## 性能优化

### 1. 关闭动画

```javascript
animation: false  // 关闭 ECharts 内置动画
```

### 2. 大数据渲染优化

```javascript
// 关闭渐进式渲染，一次性显示完整图表
progressive: 0

// 性能优化的 setOption 配置
chartInstance.setOption(option, {
  notMerge: true,        // 不合并，直接替换
  lazyUpdate: false,     // 立即更新
  silent: true,          // 静默更新，不触发事件
})
```

### 3. 数据预分配

```javascript
// 使用预分配数组代替 flatMap，提升性能
const totalPoints = rows * cols
const heatmapData = new Array(totalPoints)
let idx = 0

for (let i = 0; i < rows; i++) {
  for (let j = 0; j < cols; j++) {
    heatmapData[idx++] = [j, i, rowData[j]]
  }
}
```

### 4. 防抖处理

```javascript
// 窗口大小改变时进行防抖
resizeTimer = window.setTimeout(() => {
  // 延迟 150ms 后处理
}, 150)
```

---

## 常见问题

### Q1: 为什么矩形框不对齐？
**A**: 物理坐标需要正确转换为格点坐标，公式：
```
gridX = (physicalX / 135) * (cols - 1)
gridY = (physicalY / 135) * (rows - 1)
```

### Q2: 为什么颜色不对？
**A**: 检查温度范围的计算，特别是全 0 数据的特殊处理：
```
if (rawMinTemp === 0 && rawMaxTemp === 0) {
  minTemp = 0
  maxTemp = 1
}
```

### Q3: 为什么文字看不清？
**A**: 检查文字颜色是否根据背景自动调整：
```
const textColor = isAllZeroData ? '#ffffff' : '#1a1a1a'
```

### Q4: 热力图变黑或变白？
**A**: 可能是插值倍数过高，调整为：
- 数据 > 20000 → 1x（不插值）
- 数据 > 10000 → 2x
- 数据 ≤ 10000 → 3x

---

## 总结

热力图的核心思路是：

1. **三层坐标系转换**：物理坐标 → 格点坐标 → 像素坐标
2. **动态温度范围**：根据数据动态计算，特殊处理全 0 数据
3. **智能颜色映射**：根据显示类型选择不同色彩方案
4. **高斯插值平滑**：提高视觉效果，根据数据量自动选择倍数
5. **Graphic 矩形绘制**：独立于热力图数据维度，使用真实物理坐标
6. **自适应显示**：根据背景自动调整文字颜色和字体大小
7. **性能优化**：关闭动画、预分配数据、防抖处理

这样就能够实现一个高效、准确、视觉效果好的交互式热力图系统。

